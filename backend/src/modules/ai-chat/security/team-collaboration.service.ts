import { Injectable, Logger } from '@nestjs/common';

/**
 * ğŸ‘¥ Team Collaboration Service
 * Implements ideas #17-22: Team collaboration features
 * 
 * Features:
 * - Team directory
 * - Skill finder
 * - Availability checker
 * - Team mood board
 */

export interface TeamMember {
    id: string;
    name: string;
    nameAr: string;
    department: string;
    departmentAr: string;
    role: string;
    roleAr: string;
    skills: string[];
    email: string;
    phone?: string;
    location: string;
    availability: 'available' | 'busy' | 'away' | 'offline';
    statusMessage?: string;
}

export interface SkillSearch {
    skill: string;
    skillAr: string;
    experts: TeamMember[];
    learners: TeamMember[];
}

export interface TeamMood {
    date: Date;
    responses: number;
    averageMood: number;
    distribution: { mood: string; count: number; percentage: number }[];
    trend: 'improving' | 'stable' | 'declining';
}

export interface CollaborationRequest {
    id: string;
    fromUserId: string;
    fromUserName: string;
    toUserId: string;
    toUserName: string;
    type: 'help' | 'meeting' | 'review' | 'mentoring';
    typeAr: string;
    message: string;
    status: 'pending' | 'accepted' | 'declined';
    createdAt: Date;
}

@Injectable()
export class TeamCollaborationService {
    private readonly logger = new Logger(TeamCollaborationService.name);

    // Team directory (sample data)
    private readonly teamMembers: TeamMember[] = [
        { id: '1', name: 'Ahmed Mohammed', nameAr: 'Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯', department: 'Engineering', departmentAr: 'Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©', role: 'Senior Developer', roleAr: 'Ù…Ø·ÙˆØ± Ø£ÙˆÙ„', skills: ['javascript', 'python', 'react'], email: 'ahmed@company.com', location: 'Riyadh', availability: 'available' },
        { id: '2', name: 'Sara Abdullah', nameAr: 'Ø³Ø§Ø±Ø© Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡', department: 'HR', departmentAr: 'Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ø¨Ø´Ø±ÙŠØ©', role: 'HR Manager', roleAr: 'Ù…Ø¯ÙŠØ± Ù…ÙˆØ§Ø±Ø¯ Ø¨Ø´Ø±ÙŠØ©', skills: ['recruitment', 'training', 'labor_law'], email: 'sara@company.com', location: 'Riyadh', availability: 'busy' },
        { id: '3', name: 'Khalid Omar', nameAr: 'Ø®Ø§Ù„Ø¯ Ø¹Ù…Ø±', department: 'Engineering', departmentAr: 'Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©', role: 'DevOps Engineer', roleAr: 'Ù…Ù‡Ù†Ø¯Ø³ DevOps', skills: ['docker', 'kubernetes', 'aws'], email: 'khalid@company.com', location: 'Jeddah', availability: 'available' },
        { id: '4', name: 'Fatima Hassan', nameAr: 'ÙØ§Ø·Ù…Ø© Ø­Ø³Ù†', department: 'Finance', departmentAr: 'Ø§Ù„Ù…Ø§Ù„ÙŠØ©', role: 'Accountant', roleAr: 'Ù…Ø­Ø§Ø³Ø¨', skills: ['excel', 'sap', 'budgeting'], email: 'fatima@company.com', location: 'Riyadh', availability: 'away' },
        { id: '5', name: 'Mohammed Ali', nameAr: 'Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ', department: 'Sales', departmentAr: 'Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª', role: 'Sales Lead', roleAr: 'Ù‚Ø§Ø¦Ø¯ Ù…Ø¨ÙŠØ¹Ø§Øª', skills: ['negotiation', 'crm', 'presentation'], email: 'mohammed@company.com', location: 'Dammam', availability: 'available' },
    ];

    // Collaboration requests
    private requests: Map<string, CollaborationRequest> = new Map();

    // Mood tracking
    private moodData: Map<string, number[]> = new Map();

    /**
     * ğŸ” Search team by skill
     */
    findBySkill(skill: string): SkillSearch {
        const normalized = skill.toLowerCase();
        const skillNames: Record<string, string> = {
            javascript: 'Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª',
            python: 'Ø¨Ø§ÙŠØ«ÙˆÙ†',
            react: 'Ø±ÙŠØ§ÙƒØª',
            docker: 'Ø¯ÙˆÙƒØ±',
            aws: 'AWS',
            excel: 'Ø¥ÙƒØ³Ù„',
            recruitment: 'Ø§Ù„ØªÙˆØ¸ÙŠÙ',
            training: 'Ø§Ù„ØªØ¯Ø±ÙŠØ¨',
        };

        const experts = this.teamMembers.filter(m =>
            m.skills.some(s => s.toLowerCase().includes(normalized))
        );

        return {
            skill: normalized,
            skillAr: skillNames[normalized] || skill,
            experts,
            learners: [], // Would come from learning profiles
        };
    }

    /**
     * ğŸ‘¥ Get team by department
     */
    getTeamByDepartment(department: string): TeamMember[] {
        return this.teamMembers.filter(m =>
            m.department.toLowerCase().includes(department.toLowerCase()) ||
            m.departmentAr.includes(department)
        );
    }

    /**
     * ğŸŸ¢ Check availability
     */
    checkAvailability(userId: string): { available: boolean; status: string; statusAr: string } {
        const member = this.teamMembers.find(m => m.id === userId);
        if (!member) {
            return { available: false, status: 'unknown', statusAr: 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ' };
        }

        const statusMap: Record<string, { available: boolean; statusAr: string }> = {
            available: { available: true, statusAr: 'Ù…ØªØ§Ø­' },
            busy: { available: false, statusAr: 'Ù…Ø´ØºÙˆÙ„' },
            away: { available: false, statusAr: 'Ø¨Ø¹ÙŠØ¯' },
            offline: { available: false, statusAr: 'ØºÙŠØ± Ù…ØªØµÙ„' },
        };

        const status = statusMap[member.availability];
        return {
            available: status.available,
            status: member.availability,
            statusAr: status.statusAr,
        };
    }

    /**
     * ğŸ¤ Request collaboration
     */
    requestCollaboration(
        fromUserId: string,
        fromUserName: string,
        toUserId: string,
        type: CollaborationRequest['type'],
        message: string
    ): { success: boolean; request?: CollaborationRequest; message: string } {
        const toMember = this.teamMembers.find(m => m.id === toUserId);
        if (!toMember) {
            return { success: false, message: 'âŒ Ø§Ù„Ù…ÙˆØ¸Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
        }

        const typeNames: Record<string, string> = {
            help: 'Ø·Ù„Ø¨ Ù…Ø³Ø§Ø¹Ø¯Ø©',
            meeting: 'Ø·Ù„Ø¨ Ø§Ø¬ØªÙ…Ø§Ø¹',
            review: 'Ø·Ù„Ø¨ Ù…Ø±Ø§Ø¬Ø¹Ø©',
            mentoring: 'Ø·Ù„Ø¨ Ø¥Ø±Ø´Ø§Ø¯',
        };

        const requestId = `COLLAB-${Date.now().toString(36).toUpperCase()}`;
        const request: CollaborationRequest = {
            id: requestId,
            fromUserId,
            fromUserName,
            toUserId,
            toUserName: toMember.nameAr,
            type,
            typeAr: typeNames[type],
            message,
            status: 'pending',
            createdAt: new Date(),
        };

        this.requests.set(requestId, request);

        return {
            success: true,
            request,
            message: `âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${typeNames[type]} Ø¥Ù„Ù‰ ${toMember.nameAr}`,
        };
    }

    /**
     * ğŸ˜Š Submit team mood
     */
    submitMood(userId: string, mood: number): { success: boolean; message: string } {
        const today = new Date().toISOString().split('T')[0];
        const todayMoods = this.moodData.get(today) || [];
        todayMoods.push(Math.min(5, Math.max(1, mood)));
        this.moodData.set(today, todayMoods);

        const moodEmojis = ['ğŸ˜¢', 'ğŸ˜•', 'ğŸ˜', 'ğŸ™‚', 'ğŸ˜Š'];
        return {
            success: true,
            message: `${moodEmojis[mood - 1]} Ø´ÙƒØ±Ø§Ù‹ Ù„Ù…Ø´Ø§Ø±ÙƒØªÙƒ! ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø­Ø§Ù„ØªÙƒ.`,
        };
    }

    /**
     * ğŸ“Š Get team mood summary
     */
    getTeamMood(): TeamMood {
        const today = new Date().toISOString().split('T')[0];
        const moods = this.moodData.get(today) || [3, 4, 4, 3, 5, 4];

        const distribution = [1, 2, 3, 4, 5].map(level => ({
            mood: ['ğŸ˜¢', 'ğŸ˜•', 'ğŸ˜', 'ğŸ™‚', 'ğŸ˜Š'][level - 1],
            count: moods.filter(m => m === level).length,
            percentage: Math.round((moods.filter(m => m === level).length / moods.length) * 100),
        }));

        const average = moods.reduce((a, b) => a + b, 0) / moods.length;

        return {
            date: new Date(),
            responses: moods.length,
            averageMood: Math.round(average * 10) / 10,
            distribution,
            trend: average >= 3.5 ? 'improving' : average >= 2.5 ? 'stable' : 'declining',
        };
    }

    /**
     * ğŸ“Š Format skill search results
     */
    formatSkillSearch(result: SkillSearch): string {
        if (result.experts.length === 0) {
            return `âŒ Ù„Ù… Ø£Ø¬Ø¯ Ø®Ø¨Ø±Ø§Ø¡ ÙÙŠ "${result.skillAr}"\n\nØ¬Ø±Ø¨: javascript, python, excel, recruitment`;
        }

        let message = `ğŸ¯ **Ø®Ø¨Ø±Ø§Ø¡ ${result.skillAr}:**\n\n`;

        for (const expert of result.experts) {
            const availIcon = { available: 'ğŸŸ¢', busy: 'ğŸŸ¡', away: 'ğŸŸ ', offline: 'âš«' }[expert.availability];
            message += `${availIcon} **${expert.nameAr}**\n`;
            message += `   ğŸ“ ${expert.departmentAr} | ${expert.roleAr}\n`;
            message += `   ğŸ“§ ${expert.email}\n\n`;
        }

        return message;
    }

    /**
     * ğŸ“Š Format team directory
     */
    formatTeamDirectory(department?: string): string {
        const members = department ? this.getTeamByDepartment(department) : this.teamMembers;

        if (members.length === 0) {
            return 'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…ÙˆØ¸ÙÙŠÙ†';
        }

        let message = department ? `ğŸ‘¥ **ÙØ±ÙŠÙ‚ ${department}:**\n\n` : 'ğŸ‘¥ **Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ†:**\n\n';

        for (const member of members) {
            const availIcon = { available: 'ğŸŸ¢', busy: 'ğŸŸ¡', away: 'ğŸŸ ', offline: 'âš«' }[member.availability];
            message += `${availIcon} **${member.nameAr}** - ${member.roleAr}\n`;
            message += `   ğŸ“ ${member.location} | ğŸ“§ ${member.email}\n\n`;
        }

        return message;
    }

    /**
     * ğŸ“Š Format team mood
     */
    formatTeamMood(): string {
        const mood = this.getTeamMood();
        const trendEmoji = { improving: 'ğŸ“ˆ', stable: 'â¡ï¸', declining: 'ğŸ“‰' }[mood.trend];

        let message = `ğŸ˜Š **Ø­Ø§Ù„Ø© Ø§Ù„ÙØ±ÙŠÙ‚ Ø§Ù„ÙŠÙˆÙ…:**\n\n`;
        message += `ğŸ“Š Ø§Ù„Ù…ØªÙˆØ³Ø·: ${mood.averageMood}/5\n`;
        message += `ğŸ‘¥ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†: ${mood.responses}\n`;
        message += `${trendEmoji} Ø§Ù„Ø§ØªØ¬Ø§Ù‡: ${mood.trend === 'improving' ? 'ØªØ­Ø³Ù†' : mood.trend === 'stable' ? 'Ù…Ø³ØªÙ‚Ø±' : 'Ø§Ù†Ø®ÙØ§Ø¶'}\n\n`;

        message += `**Ø§Ù„ØªÙˆØ²ÙŠØ¹:**\n`;
        for (const d of mood.distribution) {
            const bar = 'â–ˆ'.repeat(Math.ceil(d.percentage / 10));
            message += `${d.mood} ${bar} ${d.percentage}%\n`;
        }

        return message;
    }
}
